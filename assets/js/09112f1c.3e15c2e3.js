"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[2008],{5680:(e,r,t)=>{t.d(r,{xA:()=>u,yg:()=>g});var a=t(6540);function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function s(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?s(Object(t),!0).forEach((function(r){n(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function o(e,r){if(null==e)return{};var t,a,n=function(e,r){if(null==e)return{};var t,a,n={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],r.indexOf(t)>=0||(n[t]=e[t]);return n}(e,r);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=a.createContext({}),c=function(e){var r=a.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},u=function(e){var r=c(e.components);return a.createElement(l.Provider,{value:r},e.children)},d="mdxType",y={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},p=a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,s=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(t),p=n,g=d["".concat(l,".").concat(p)]||d[p]||y[p]||s;return t?a.createElement(g,i(i({ref:r},u),{},{components:t})):a.createElement(g,i({ref:r},u))}));function g(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var s=t.length,i=new Array(s);i[0]=p;var o={};for(var l in r)hasOwnProperty.call(r,l)&&(o[l]=r[l]);o.originalType=e,o[d]="string"==typeof e?e:n,i[1]=o;for(var c=2;c<s;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},3561:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>y,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=t(8168),n=(t(6540),t(5680));const s={},i="Structured Data (Structures, Arrays and String Operations)",o={unversionedId:"Lab 7 - Structures, vectors and strings/Arrays/Reading/README",id:"Lab 7 - Structures, vectors and strings/Arrays/Reading/README",title:"Structured Data (Structures, Arrays and String Operations)",description:"Arrays",source:"@site/docs/Lab 7 - Structures, vectors and strings/Arrays/Reading/README.md",sourceDirName:"Lab 7 - Structures, vectors and strings/Arrays/Reading",slug:"/Lab 7 - Structures, vectors and strings/Arrays/Reading/",permalink:"/hardware-software-interface/Lab 7 - Structures, vectors and strings/Arrays/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Arrays",permalink:"/hardware-software-interface/Lab 7 - Structures, vectors and strings/Arrays/"},next:{title:"Guides",permalink:"/hardware-software-interface/Lab 7 - Structures, vectors and strings/Arrays/Guides/"}},l={},c=[{value:"Arrays",id:"arrays",level:2},{value:"Declaring an Array",id:"declaring-an-array",level:3},{value:"Arrays of Structures",id:"arrays-of-structures",level:2},{value:"Declaring an Array of Structures",id:"declaring-an-array-of-structures",level:3},{value:"Traversing an Array of Structures",id:"traversing-an-array-of-structures",level:3}],u={toc:c},d="wrapper";function y(e){let{components:r,...t}=e;return(0,n.yg)(d,(0,a.A)({},u,t,{components:r,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"structured-data-structures-arrays-and-string-operations"},"Structured Data (Structures, Arrays and String Operations)"),(0,n.yg)("h2",{id:"arrays"},"Arrays"),(0,n.yg)("p",null,"We can consider an array as a sequence of elements of the same type, placed contiguously in memory.\nYou might have noticed something similar in previous labs when declaring static character strings in the ",(0,n.yg)("inlineCode",{parentName:"p"},".data")," section."),(0,n.yg)("h3",{id:"declaring-an-array"},"Declaring an Array"),(0,n.yg)("p",null,"In general, declared static data can be initialized or uninitialized.\nDifferentiation is made both by providing an initial value for initialized data and by the NASM syntax used."),(0,n.yg)("p",null,"For example, to declare an array of 100 words initialized with the value 42, we will use the construction:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .data\n    my_vect:    times 100    dw 42\n")),(0,n.yg)("p",null,'On the other hand, if we want to declare an uninitialized array of 20 double-word elements, we use instructions from the "res" family as follows:'),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .bss\n    my_vect:    resd 20\n")),(0,n.yg)("h2",{id:"arrays-of-structures"},"Arrays of Structures"),(0,n.yg)("p",null,"Often, we'll need arrays that contain elements larger than a double word.\nTo achieve this, we'll combine the two concepts presented earlier and use arrays of structures.\nOf course, string operation instructions will not work, so we'll have to resort to the classic method of accessing elements: explicit memory addressing."),(0,n.yg)("p",null,"For the example in this section, we create a structure representing a point in a 2D space."),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-Assembly"},"struc point\n    .x:    resd 1\n    .y:    resd 1\nendstruc\n")),(0,n.yg)("h3",{id:"declaring-an-array-of-structures"},"Declaring an Array of Structures"),(0,n.yg)("p",null,"Since NASM doesn't support any mechanism to explicitly declare an array of structures, we'll need to effectively declare a data section to accommodate our array."),(0,n.yg)("p",null,"Suppose we want a zero-initialized array of 100 elements of the structure type ",(0,n.yg)("inlineCode",{parentName:"p"},"point")," (which is 8 bytes in size), we need to allocate 100 * 8 (= 800) bytes."),(0,n.yg)("p",null,"We obtain:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .data\n    point_array:    times 800    db 0\n")),(0,n.yg)("p",null,"In addition, NASM provides an alternative to manually calculating the size of a structure by automatically generating the macro ",(0,n.yg)("inlineCode",{parentName:"p"},"<structure name>_size"),".\nThus, the previous example can become:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .data\n    point_array:    times point_size * 100    db 0\n")),(0,n.yg)("p",null,"If we want to declare an uninitialized array of structures, we can use:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .bss\n    point_array:    resb point_size * 100\n")),(0,n.yg)("h3",{id:"traversing-an-array-of-structures"},"Traversing an Array of Structures"),(0,n.yg)("p",null,'As mentioned before, to access a field of an element in an array, we need to use normal addressing (particularly "based-indexed with scale" addressing).\nThe formula to find the address of the element is ',(0,n.yg)("inlineCode",{parentName:"p"},"base_of_array + i * size_of_struct"),"."),(0,n.yg)("p",null,"Assuming we have the start address of the array in the ",(0,n.yg)("inlineCode",{parentName:"p"},"ebx")," register and the index of the element we want to access in the ",(0,n.yg)("inlineCode",{parentName:"p"},"eax")," register, the following example demonstrates printing the value of the y field of this element."),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov ebx, point_array                            ; Move the start address of the array into ebx\nmov eax, 13                                     ; Assume we want the 14th element\nmov edx, [ebx + point_size * eax + point.y]     ; Calculate the address of the desired field between []\n                                                ; and then transfer the value from that address\n                                                ; into the edx register\n\nPRINTF32 `%u\\n\\x0`, edx\n")),(0,n.yg)("p",null,"We traverse the array, having the current index in the eax register at each iteration.\nWe can print the values from both fields of each element in the array with the following program:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-Assembly"},"struc   point\n    .x: resd 1\n    .y: resd 1\nendstruc\n\nsection .data\n    point_array: times point_size * 100 db 0\n\nsection .text\n    global CMAIN\n\nCMAIN:\n    push ebp\n    mov ebp, esp\n\n    xor edx, edx\n    xor eax, eax\n\nlabel:\n    mov edx, [point_array + point_size * eax + point.x] ; access x member\n    PRINTF32 `%u\\n\\x0`, edx\n\n    mov edx, [point_array + point_size * eax + point.y] ; access y member\n    PRINTF32 `%u\\n\\x0`, edx\n\n    inc eax ; increment input index\n    cmp eax, 100\n    jl label\n\n    leave\n    ret\n")))}y.isMDXComponent=!0}}]);